<!DOCTYPE html>
<html>
<head>
<title>netty.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///c%3A/Users/DWK/Desktop/netty/lavender/Lavender.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="netty%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93">Netty基础总结</h1>
<h2 id="1io%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%AF%B4%E6%98%8E">1、IO类型及说明</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>说明</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIO</td>
<td>同步并阻塞IO</td>
<td>服务器实现模式为一个连接对应一个线程，<br />客户端连接过多会严重影响性能</td>
<td>连接数少且固定的架构，对服务器资源要求高，并发局限于应用中，如数据库连接</td>
</tr>
<tr>
<td>NIO</td>
<td>同步非阻塞IO</td>
<td>服务器实现模式为一个线程处理多个连接，<br />即客户端发送的连接请求都会注册到多路复用上；<br />多路复用器轮询到有IO请求就进行处理</td>
<td>连接数多且连接较短的架构，如聊天、弹幕、服务器间通讯</td>
</tr>
<tr>
<td>AIO</td>
<td>异步非阻塞IO</td>
<td>无论是客户端的连接请求还是读写请求都会异步执行；</td>
<td>连接数较多且连接较长的架构，充分调用操作系统参与</td>
</tr>
</tbody>
</table>
<h2 id="2bio%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">2、BIO基本介绍</h2>
<p>1、传统的Java io编程、其相关的类和接口在java.io包下</p>
<p>2、同步阻塞。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</p>
<p>3、执行流程：</p>
<p><img src="image/netty/BIO的处理流程.png" alt=""></p>
<pre><code>服务器端启动一个ServerSocket

客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户端建立一个线程与之通讯

客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待或者被拒绝  如果有响应，客户端会等待请求结束后才继续执行
</code></pre>
<p>4、模型：</p>
<p><img src="image/netty/BIO模型.png" alt=""></p>
<h2 id="3nio%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">3、NIO基本介绍</h2>
<p>1、原生jdk io上的一个改进 同步非阻塞！</p>
<p>2、三大核心组件:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>理解</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Channel</td>
<td>通道</td>
<td>一个Channel就代表一个连接</td>
<td><img src="image/netty/Channel概念.png" alt="img"></td>
</tr>
<tr>
<td>Buffer</td>
<td>缓冲区</td>
<td>用于临时存储的一块内存</td>
<td><img src="image/netty/ByteBuf概念.png" alt=""></td>
</tr>
<tr>
<td>Selector</td>
<td>选择器</td>
<td>对Channel的一个管理器，监听通道的事件</td>
<td></td>
</tr>
</tbody>
</table>
<p>3、模型：</p>
<p><img src="image/netty/NIO模型.png" alt=""></p>
<p>4、特性：</p>
<p>    a.  面向缓冲，数据读取到一个它稍后处理的缓冲区，需要时可以在缓冲区中前后移动，这就增加了处理过程中的灵活性，可以提供非阻塞的高伸缩性网格；</p>
<p>    b.  非阻塞；</p>
<p>    c.  通过选择器来模拟多线程；</p>
<h2 id="4nio%E5%92%8Cbio%E5%8C%BA%E5%88%AB">4、NIO和BIO区别</h2>
<p>1、BIO以流的方式处理数据，NIO以块的方式处理数据，块的效率 &gt; 流的效率</p>
<p>2、BIO阻塞   NIO非阻塞</p>
<p>3、BIO基于字节流和字符流进行操作；NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道内读取到缓冲区或者从缓冲区写入到通道。</p>
<p>4、BIO监听一个连接需要一个线程，NIO中一个线程可以监听多个连接</p>
<h2 id="5nio%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">5、NIO三大核心原理</h2>
<p>1、每个channel都对应一个buffer</p>
<p>2、selector对应一个线程，一个线程对应多个channel</p>
<p>3、selector选择哪个channel是由事件决定的</p>
<p>4、数据的读写都是操作的buffer</p>
<p>5、BIO中要么是输入流要么是输出流，NIO中的Buffer可读也可写</p>
<h2 id="6buffer%E5%92%8Cchannel%E7%9A%84%E6%B3%A8%E6%84%8F%E7%BB%86%E8%8A%82">6、Buffer和Channel的注意细节</h2>
<p>1、ByteBuffer支持类型化的put和get，put放入的是什么数据类型  get就应该使用相应的类型来取出</p>
<p>2、可以改变Buffer的可读性</p>
<p>3、NIO提供MappedByteBuffer，可以直接让文件在内存中修改(堆外内存)，相当于直接在操作系统上操作文件而不用再拷贝一份进行操作，效率快</p>
<p>4、读写操作可以通过一个Buffer来操作，NIO还支持通过多个Buffer操作即Buffer数组形式操作</p>
<h2 id="7nio%E9%83%A8%E5%88%86demo%E4%BB%A3%E7%A0%81">7、NIO部分demo代码</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.dwk.nio;

<span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.net.ServerSocket;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.IntBuffer;
<span class="hljs-keyword">import</span> java.nio.MappedByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.*;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/**
 * nio 案例实现
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioDemo</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">//buffer的基本使用</span>
        <span class="hljs-comment">//intBuffTest(5);</span>

        <span class="hljs-comment">//channel的基本使用</span>
        <span class="hljs-comment">//channelTest();</span>

        <span class="hljs-comment">//文件拷贝</span>
        <span class="hljs-comment">//transferFormTest("","");</span>

        <span class="hljs-comment">//buffer的存取</span>
        <span class="hljs-comment">//bufferPutGet();</span>

        <span class="hljs-comment">//buffer的只读</span>
        <span class="hljs-comment">//readOnlyBuffer();</span>

        <span class="hljs-comment">//使用byteBuffer数组读取进行数据交互</span>
        bufferArray();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">intBuffTest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>{
        <span class="hljs-comment">//创建一个容量大小为capacity的buff</span>
        IntBuffer allocate = IntBuffer.allocate(capacity);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; capacity; i++) {
            allocate.put(i * <span class="hljs-number">2</span>);
        }
        <span class="hljs-comment">//将buffer切换，读写切换  处理buffer内的标记</span>
        allocate.flip();
        <span class="hljs-comment">//指定开始读取的位置</span>
        <span class="hljs-comment">//allocate.position(1);</span>
        <span class="hljs-comment">//指定结束读取的位置</span>
        <span class="hljs-comment">//allocate.limit(2);</span>
        <span class="hljs-keyword">while</span> (allocate.hasRemaining()){
            System.out.println(allocate.get());
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelTest</span><span class="hljs-params">()</span></span>{
        <span class="hljs-comment">//DatagramChannel  用于UDP数据的读写，ServerSocketChannel/SocketChannel用于TCP的数据读写</span>

        <span class="hljs-comment">//文件写通道</span>
        fileChannelWriteTest();
        <span class="hljs-comment">//文件读通道</span>
        fileChannelReadTest();
        <span class="hljs-comment">//使用一个通道完成文件的读写 - 文件拷贝</span>
        fileChannelWriteAndReadTest();

    }

    <span class="hljs-comment">/**
     * 文件写入
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fileChannelWriteTest</span><span class="hljs-params">()</span></span>{
        FileOutputStream fileOutputStream = <span class="hljs-keyword">null</span>;
        FileChannel fileChannel = <span class="hljs-keyword">null</span>;
        ByteBuffer byteBuffer;
        <span class="hljs-keyword">try</span> {
            String str = <span class="hljs-string">"fileChannelTest"</span>;
            fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"C:\\duwk\\code\\myself\\frame-master\\netty\\src\\main\\resources\\file\\FileChannel.txt"</span>);
            <span class="hljs-comment">//获取通道</span>
            fileChannel = fileOutputStream.getChannel();
            <span class="hljs-comment">//创建缓冲区</span>
            byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);
            <span class="hljs-comment">//写入缓冲区</span>
            byteBuffer.put(str.getBytes(<span class="hljs-string">"UTF-8"</span>));
            <span class="hljs-comment">//缓冲区索引重置</span>
            byteBuffer.flip();
            <span class="hljs-comment">//缓冲区数据写入通道</span>
            fileChannel.write(byteBuffer);
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        } <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
                fileOutputStream.close();
                fileChannel.close();
            } <span class="hljs-keyword">catch</span> (IOException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }
        }
    }

    <span class="hljs-comment">/**
     * 文件读取
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fileChannelReadTest</span><span class="hljs-params">()</span></span>{
        FileInputStream fileInputStream = <span class="hljs-keyword">null</span>;
        ByteBuffer byteBuffer = <span class="hljs-keyword">null</span>;
        FileChannel channel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            String filePath = <span class="hljs-string">"C:\\duwk\\code\\myself\\frame-master\\netty\\src\\main\\resources\\file\\FileChannel.txt"</span>;
            File file = <span class="hljs-keyword">new</span> File(filePath);
            fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);
            <span class="hljs-comment">//通道读取文件</span>
            channel = fileInputStream.getChannel();
            <span class="hljs-comment">//缓冲区读取通道</span>
            byteBuffer = ByteBuffer.allocate((<span class="hljs-keyword">int</span>) file.length());
            channel.read(byteBuffer);
            byteBuffer.flip();
            <span class="hljs-comment">//缓冲区数据输出</span>
            System.out.println(<span class="hljs-keyword">new</span> String(byteBuffer.array(),<span class="hljs-string">"UTF-8"</span>));
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
                fileInputStream.close();
                channel.close();
            } <span class="hljs-keyword">catch</span> (IOException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }
        }
    }

    <span class="hljs-comment">/**
     * 文件拷贝
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fileChannelWriteAndReadTest</span><span class="hljs-params">()</span></span>{
        FileOutputStream outputStream = <span class="hljs-keyword">null</span>;
        FileInputStream inputStream = <span class="hljs-keyword">null</span>;
        ByteBuffer byteBuffer = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            String fileName = <span class="hljs-string">"C:\\duwk\\code\\myself\\frame-master\\netty\\src\\main\\resources\\file\\FileChannel.txt"</span>;
            String targetFileName = <span class="hljs-string">"C:\\duwk\\code\\myself\\frame-master\\netty\\src\\main\\resources\\file\\FileChannel副本.txt"</span>;
            File file = <span class="hljs-keyword">new</span> File(fileName);
            File fileClone = <span class="hljs-keyword">new</span> File(targetFileName);
            <span class="hljs-keyword">if</span> (fileClone.exists()) {
                fileClone.delete();
                fileChannelWriteAndReadTest();
            }
            inputStream = <span class="hljs-keyword">new</span> FileInputStream(file);
            <span class="hljs-comment">//读取源文件流到通道</span>
            FileChannel inChannel = inputStream.getChannel();
            <span class="hljs-comment">//通道中的数据流写入到缓冲区</span>
            byteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);
            inChannel.read(byteBuffer);
            byteBuffer.flip();
            <span class="hljs-comment">//将缓冲区中的数据流写入到另一个通道</span>
            outputStream = <span class="hljs-keyword">new</span> FileOutputStream(fileClone);
            FileChannel outChannel = outputStream.getChannel();
            outChannel.write(byteBuffer);
        }<span class="hljs-keyword">catch</span> (Exception e){
            e.printStackTrace();
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
                outputStream.close();
                inputStream.close();
            } <span class="hljs-keyword">catch</span> (IOException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }
        }

    }

    <span class="hljs-comment">/**
     * buffer的类型存取  按顺序存取
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bufferPutGet</span><span class="hljs-params">()</span></span>{
        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);

        byteBuffer.putInt(<span class="hljs-number">1</span>);
        byteBuffer.putLong(<span class="hljs-number">1L</span>);
        byteBuffer.putChar(<span class="hljs-string">'A'</span>);
        byteBuffer.putShort((<span class="hljs-keyword">short</span>) <span class="hljs-number">1</span>);

        byteBuffer.flip();

        <span class="hljs-comment">//正常取出</span>
        <span class="hljs-keyword">int</span> anInt = byteBuffer.getInt();
        <span class="hljs-keyword">long</span> aLong = byteBuffer.getLong();
        <span class="hljs-keyword">char</span> aChar = byteBuffer.getChar();
        <span class="hljs-keyword">short</span> aShort = byteBuffer.getShort();

        System.out.println(anInt);
        System.out.println(aLong);
        System.out.println(aChar);
        System.out.println(aShort);

        System.out.println(<span class="hljs-string">"======================"</span>);

        <span class="hljs-comment">//乱序取出  有异常</span>
        <span class="hljs-keyword">short</span> bShort = byteBuffer.getShort();
        <span class="hljs-keyword">char</span> bChar = byteBuffer.getChar();
        <span class="hljs-keyword">long</span> bLong = byteBuffer.getLong();
        <span class="hljs-keyword">int</span> bnInt = byteBuffer.getInt();

        System.out.println(bnInt);
        System.out.println(bLong);
        System.out.println(bChar);
        System.out.println(bShort);
    }

    <span class="hljs-comment">/**
     * 设置buffer只读
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readOnlyBuffer</span><span class="hljs-params">()</span></span>{
        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">64</span>);
        byteBuffer.putInt(<span class="hljs-number">1</span>);
        <span class="hljs-comment">//设置只读</span>
        byteBuffer.asReadOnlyBuffer();
        <span class="hljs-keyword">int</span> anInt = byteBuffer.getInt();
        System.out.println(<span class="hljs-string">"buffer只读 ==&gt;"</span> + anInt);
    }

    <span class="hljs-comment">/**
     * 使用通道的transferFrom方法拷贝文件
     * <span class="hljs-doctag">@param</span> sourcePath 源文件路径
     * <span class="hljs-doctag">@param</span> targetPath 目标文件路径
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transferFormTest</span><span class="hljs-params">(String sourcePath,String targetPath)</span></span>{
        FileInputStream inputStream = <span class="hljs-keyword">null</span>;
        FileOutputStream outputStream = <span class="hljs-keyword">null</span>;
        FileChannel inputStreamChannel = <span class="hljs-keyword">null</span>;
        FileChannel outputStreamChannel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//创建文件流</span>
            inputStream = <span class="hljs-keyword">new</span> FileInputStream(sourcePath);
            outputStream = <span class="hljs-keyword">new</span> FileOutputStream(targetPath);
            <span class="hljs-comment">//信道</span>
            inputStreamChannel = inputStream.getChannel();
            outputStreamChannel = outputStream.getChannel();
            <span class="hljs-comment">//拷贝  参数：src = 源通道   position = 文件内开始转移的位置，必须是非负数   count = 最大的转换字节数，必须非负数</span>
            outputStreamChannel.transferFrom(inputStreamChannel,<span class="hljs-number">0</span>,inputStreamChannel.size());

        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-comment">//关闭通道和流</span>
                inputStreamChannel.close();
                outputStreamChannel.close();
                inputStream.close();
                outputStream.close();
            } <span class="hljs-keyword">catch</span> (IOException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }
        }
    }

    <span class="hljs-comment">/**
     * 零拷贝
     * mappedByteBuffer - 可以让文件直接在内存(堆外内存)中进行修改，操作系统不必拷贝一次  NIO同步到文件
     * 相当于直接操作源文件，性能高，但是不安全
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mappedByteBufferTest</span><span class="hljs-params">()</span></span>{
        RandomAccessFile randomAccessFile = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//name : 文件名  mode：模式（r，rw，rws，rwd）</span>
            randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(<span class="hljs-string">""</span>, <span class="hljs-string">""</span>);
            <span class="hljs-comment">//获取通道</span>
            FileChannel channel = randomAccessFile.getChannel();
            <span class="hljs-comment">//MapMode mode   模式, long position  可以直接修改的起始位置, long size   映射到内存的大小(不是索引位置)即文件的多少个字节映射到内存</span>
            MappedByteBuffer map = channel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
            <span class="hljs-comment">//修改文件</span>
            map.put(<span class="hljs-number">0</span>,(<span class="hljs-keyword">byte</span>) <span class="hljs-string">'A'</span>);
            map.put(<span class="hljs-number">10</span>,(<span class="hljs-keyword">byte</span>) <span class="hljs-string">'B'</span>);
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
                randomAccessFile.close();
            } <span class="hljs-keyword">catch</span> (IOException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }
        }
    }

    <span class="hljs-comment">/**
     * buffer的分散和聚集
     * buffer数组操作   Scattering:将数据写入到buffer时可以采用buffer数组依次写入  Gathering：从buffer读取数据时依次读取buffer数组
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bufferArray</span><span class="hljs-params">()</span></span>{
        <span class="hljs-comment">//服务端通道</span>
        ServerSocketChannel serverSocketChannel = <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">//客户端通道</span>
        SocketChannel socketChannel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//创建服务端通道</span>
            serverSocketChannel = ServerSocketChannel.open();
            <span class="hljs-comment">//指定端口</span>
            InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">6666</span>);
            <span class="hljs-comment">//绑定端口并启动</span>
            serverSocketChannel.socket().bind(inetSocketAddress);
            <span class="hljs-comment">//服务端的buffer数组</span>
            ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> ByteBuffer[<span class="hljs-number">2</span>];
            <span class="hljs-comment">//初始化buffer大小</span>
            byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);
            byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);
            <span class="hljs-comment">//等待客户端连接</span>
            socketChannel = serverSocketChannel.accept();
            <span class="hljs-comment">//每次从客户端通道读取的字节数</span>
            <span class="hljs-keyword">int</span> countByte = <span class="hljs-number">8</span>;
            <span class="hljs-comment">//获取客户端发送的数据,,循环读取</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){
                <span class="hljs-comment">//统计读取的字节数</span>
                <span class="hljs-keyword">int</span> byteRead = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (byteRead &lt; countByte){
                    <span class="hljs-comment">//从客户端通道读取字节到buffer数组</span>
                    <span class="hljs-keyword">long</span> read = socketChannel.read(byteBuffers);
                    byteRead += read;
                    System.out.println(<span class="hljs-string">"累计读取的字节:"</span> + byteRead);
                    Arrays.stream(byteBuffers).map(buffer -&gt; <span class="hljs-string">"position = "</span> + buffer.position() + <span class="hljs-string">"    limit = "</span> + buffer.limit()).forEach(System.out::println);
                }
                <span class="hljs-comment">//将所有的buffer反转</span>
                Arrays.stream(byteBuffers).forEach(buffer -&gt; {buffer.flip();});
                <span class="hljs-comment">//将数据读出显示到客户端</span>
                <span class="hljs-keyword">long</span> byteWrite = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (byteWrite &lt; countByte){
                    <span class="hljs-keyword">long</span> writeByte = socketChannel.write(byteBuffers);
                    byteWrite += writeByte;
                }
                <span class="hljs-comment">//将所有的buffer清除</span>
                Arrays.stream(byteBuffers).forEach(buffer -&gt; {buffer.clear();});

                System.out.println(<span class="hljs-string">"byteRead : "</span> + byteRead + <span class="hljs-string">"  byteWrite : "</span> + byteWrite + <span class="hljs-string">"  byteCount : "</span> + countByte);
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
                serverSocketChannel.close();
                socketChannel.close();
            } <span class="hljs-keyword">catch</span> (IOException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }
        }
    }

}

</div></code></pre>
<h2 id="8selector%E9%80%89%E6%8B%A9%E5%99%A8%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">8、Selector选择器基本介绍</h2>
<p>1、Java的NIO用非阻塞的IO方式。可以用一个线程处理多个客户端的连接，就会使用到Selector(选择器)</p>
<p>2、Selector能检测多个通道上是否有事件发生(多个Channel以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p>
<p>3、只用在真正有读写事件发生时，才会进行读写，减少系统开销，不用为每个连接都创建一个线程</p>
<p>4、避免了线程上下文切换的问题</p>
<p>5、Selector示意图和特点说明</p>
<p><img src="image/netty/Selector特点说明.png" alt=""></p>
<h2 id="9nio%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">9、NIO非阻塞网络编程原理分析</h2>
<p><img src="image/netty/NIO非阻塞网络编程原理分析图.png" alt=""></p>
<p>Selector、SelectorKey、ServerSocketChannel、SocketChannel之间的关系如图；</p>
<p>1、当客户端连接时，会通过ServerSocketChannel得到SocketChannel；</p>
<p>2、将SocketChannel注册到指定的Selector上，一个Selector上可以注册多个SocketChannel；</p>
<p>3、注册后返回一个SelectionKey会和该Selector关联(集合)；</p>
<p>4、Selector进行监听select方法，返回有事件发生的通道的个数；</p>
<p>5、进一步得到各个SelectionKey(有事件发生)；</p>
<p>6、再通过SelectionKey反向获取SocketChannel；</p>
<p>7、可以通过得到的SocketChannel完成业务处理；</p>
<p>8、demo代码：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.dwk.netty;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.net.InetSocketAddress;
<span class="hljs-keyword">import</span> java.nio.ByteBuffer;
<span class="hljs-keyword">import</span> java.nio.channels.*;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/**
 * netty  demo
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyDemo</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        chatting();
    }

    <span class="hljs-comment">/**
     * 非阻塞实现服务端和客户端之间通信
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">chatting</span> <span class="hljs-params">()</span> </span>{
        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; {
            serverTest();
        });
        Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {
            clientTest();
        });
        thread.start();
        <span class="hljs-comment">//等待两秒启动客户端</span>
        <span class="hljs-keyword">try</span> {
            Thread.sleep(<span class="hljs-number">2000</span>);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
        thread1.start();
    }


    <span class="hljs-comment">/**
     * 服务器端
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serverTest</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
            Selector selector = Selector.open();
            InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">6666</span>);
            serverSocketChannel.socket().bind(inetSocketAddress);
            <span class="hljs-comment">//设置非阻塞</span>
            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);
            <span class="hljs-comment">//服务端的socketChannel注册到selector 并设置监听事件为准备连接事件</span>
            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
            <span class="hljs-comment">//循环等待客户端连接</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){
                <span class="hljs-comment">//阻塞一秒后事件数量若为0则没有连接事件发生</span>
                <span class="hljs-keyword">boolean</span> nothing = selector.select(<span class="hljs-number">1000</span>) == <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (nothing){
                    System.out.println(<span class="hljs-string">"服务器等待了1秒，无连接"</span>);
                    <span class="hljs-keyword">continue</span>;
                }
                <span class="hljs-comment">//有事件发生,获取到事件的selectionKey集合</span>
                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
                <span class="hljs-comment">//通过selectionKey反向获取通道</span>
                selectionKeys.forEach(selectionKey -&gt; {
                    <span class="hljs-comment">//判断事件类型</span>
                    <span class="hljs-comment">//客户端连接事件</span>
                    <span class="hljs-keyword">boolean</span> acceptable = selectionKey.isAcceptable();
                    <span class="hljs-comment">//</span>
                    <span class="hljs-keyword">boolean</span> connectable = selectionKey.isConnectable();
                    <span class="hljs-comment">//客户端写事件</span>
                    <span class="hljs-keyword">boolean</span> writable = selectionKey.isWritable();
                    <span class="hljs-comment">//</span>
                    <span class="hljs-keyword">boolean</span> valid = selectionKey.isValid();
                    <span class="hljs-comment">//客户端读事件</span>
                    <span class="hljs-keyword">boolean</span> readable = selectionKey.isReadable();

                    <span class="hljs-keyword">if</span> (acceptable){
                        <span class="hljs-comment">//处理连接事件</span>
                        <span class="hljs-keyword">try</span> {
                            <span class="hljs-comment">//客户端连接事件，，给客户端生成一个非阻塞的SocketChannel</span>
                            SocketChannel socketChannel = serverSocketChannel.accept();
                            socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);
                            <span class="hljs-comment">//将socketChannel注册到selector,设置监听事件为准备读事件,并关联一个Buffer</span>
                            socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="hljs-number">1024</span>));
                        } <span class="hljs-keyword">catch</span> (IOException e) {
                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
                        }
                    }

                    <span class="hljs-keyword">if</span> (readable){
                        <span class="hljs-keyword">try</span> {
                            <span class="hljs-comment">//处理读取事件</span>
                            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
                            <span class="hljs-comment">//获取channel关联的buffer</span>
                            ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();
                            socketChannel.read(buffer);
                            System.out.println(<span class="hljs-string">"客户端发送的数据："</span> + <span class="hljs-keyword">new</span> String(buffer.array()));
                        } <span class="hljs-keyword">catch</span> (IOException e) {
                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
                        }
                    }

                    <span class="hljs-comment">//移除集合中的selectionKey，防止重复操作</span>
                    selectionKeys.remove(selectionKey);
                });
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
    }

    <span class="hljs-comment">/**
     * 客户端
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clientTest</span><span class="hljs-params">()</span></span>{
        String data = <span class="hljs-string">"我是数据！"</span>;
        <span class="hljs-keyword">try</span> {
            SocketChannel socketChannel = SocketChannel.open();
            <span class="hljs-comment">//设置非阻塞</span>
            socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);
            <span class="hljs-comment">//设置服务器端的ip和端口</span>
            InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6666</span>);
            <span class="hljs-comment">//连接服务器</span>
            <span class="hljs-keyword">boolean</span> connect = socketChannel.connect(inetSocketAddress);
            <span class="hljs-keyword">if</span> (!connect){
                System.out.println(<span class="hljs-string">"客户端正在连接..."</span>);
                <span class="hljs-keyword">while</span> (!socketChannel.finishConnect()){
                    <span class="hljs-comment">//客户端还没有连接成功，可以先处理其他逻辑</span>
                    System.out.println(<span class="hljs-string">"客户端还没有连接成功，还在连接!"</span>);
                }
            }
            System.out.println(<span class="hljs-string">"客户端连接成功！发送数据给服务端..."</span>);
            ByteBuffer byteBuffer = ByteBuffer.wrap(data.getBytes());
            <span class="hljs-keyword">int</span> write = socketChannel.write(byteBuffer);
            <span class="hljs-keyword">if</span> (write == data.getBytes().length){
                System.out.println(<span class="hljs-string">"客户端数据发送完成！"</span>);
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
    }

}

</div></code></pre>
<h2 id="10serversocketchannel%E5%92%8Csocketchannel">10、ServerSocketChannel和SocketChannel</h2>
<table>
<thead>
<tr>
<th></th>
<th>ServerSocketChannel</th>
<th>SocketChannel</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用</td>
<td>在服务器端监听新的客户端Socket连接，偏向连接</td>
<td>网络IO通道，具体负责读写操作，NIO把缓冲区的数据写入通道或者把通道内的数据读入缓冲区<br />偏向数据的读写、有分散和聚集操作</td>
</tr>
<tr>
<td>类图</td>
<td><img src="" alt=""><img src="image/netty/ServerSocketChannel类图.png" alt=""></td>
<td><img src="" alt=""><img src="image/netty/SocketChannel类图.png" alt=""></td>
</tr>
<tr>
<td>方法</td>
<td><img src="" alt=""><img src="image/netty/ServerSocketChannel方法.png" alt=""></td>
<td><img src="" alt=""><img src="image/netty/SocketChannel方法.png" alt=""></td>
</tr>
</tbody>
</table>
<h2 id="11%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">11、零拷贝基本介绍</h2>
<p>Java中常用的零拷贝有mmp(内存映射)和sendFile；零拷贝是网络编程中对性能优化的一个重要操作！</p>
<p>1、传统IO数据读写：</p>
<p><img src="image/netty/传统IO数据读写.png" alt=""></p>
<p>    1、磁盘到内核 -&gt; DMA拷贝（直接内存拷贝，不使用CPU）</p>
<p>    2、内核到用户buffer -&gt; CPU拷贝</p>
<p>    3、用户buffer到socket buffer -&gt; CPU拷贝</p>
<p>    4、socket buffer到协议栈(协议引擎) -&gt; DMA拷贝</p>
<p><strong>传统IO经过4次拷贝3次切换</strong></p>
<p>2、mmap优化(内存映射优化)</p>
<p>mmap通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间数据；网络传输时可以减少内核空间到用户空间的拷贝次数</p>
<p>    1、磁盘到内核 -&gt; DMA拷贝（直接内存拷贝，不使用CPU）</p>
<p>    2、用户空间共享内核</p>
<p>    3、用户buffer到socket buffer -&gt; CPU拷贝</p>
<p>    4、socket buffer到协议栈(协议引擎) -&gt; DMA拷贝</p>
<p><strong>3次拷贝3次切换</strong></p>
<p>3、sendFile优化</p>
<p>数据不用经过用户态，直接从内核缓冲区进入到Socket Buffer，同时，由于和用户态完全无关就减少了一次上下文切换</p>
<pre><code>Linux2.1版本
</code></pre>
<p>    1、磁盘到内核 -&gt; DMA拷贝（直接内存拷贝，不使用CPU）</p>
<p>    2、内核到Socket Buffer -&gt; CPU拷贝</p>
<p>    3、Socket Buffer到协议栈(协议引擎) -&gt; DMA拷贝</p>
<p><strong>3次拷贝2次切换</strong></p>
<pre><code>Linux2.4版本(真正意义上的零拷贝)
</code></pre>
<p>    1、磁盘到内核 -&gt; DMA拷贝（直接内存拷贝，不使用CPU）</p>
<p>    2、内核到协议栈(协议引擎) -&gt; DMA拷贝</p>
<p><strong>2次拷贝2次切换</strong></p>
<p><strong>零拷贝从操作系统看，指的是没有CPU拷贝，并不是不拷贝</strong></p>
<p>mmap和sendFile区别：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>mmap</th>
<th>sendFile</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>适合小数据量读写</td>
<td>适合大文件传输</td>
</tr>
<tr>
<td>2</td>
<td>4次上下文切换，3次数据拷贝</td>
<td>3次上下文切换，最少2次数据拷贝</td>
</tr>
<tr>
<td>3</td>
<td>必须从内核拷贝到Socket Channel缓冲区</td>
<td>可以利用DMA方式减少CPU拷贝</td>
</tr>
</tbody>
</table>
<p>4、NIO零拷贝demo：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZeroCopy</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">//传统IO</span>
        oldIO();
        <span class="hljs-comment">//NIO 零拷贝</span>
        newIO();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oldIO</span><span class="hljs-params">()</span></span>{
        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; {
            oldServer();
        });
        Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {
            oldClient();
        });
        thread.start();
        <span class="hljs-keyword">try</span> {
            Thread.sleep(<span class="hljs-number">1000</span>);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
        thread1.start();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newIO</span><span class="hljs-params">()</span></span>{
        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; {
            newServer();
        });
        Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; {
            newClkient();
        });
        thread.start();
        <span class="hljs-keyword">try</span> {
            Thread.sleep(<span class="hljs-number">1000</span>);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
        thread1.start();
    }

    <span class="hljs-comment">/**
     * 传统IO服务端
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oldServer</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {
            ServerSocket server = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>);
            <span class="hljs-comment">//等待客户端连接</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){
                Socket client = server.accept();
                <span class="hljs-comment">//获取连接的客户端的数据</span>
                InputStream inputStream = client.getInputStream();
                DataInputStream dataInputStream = <span class="hljs-keyword">new</span> DataInputStream(inputStream);
                <span class="hljs-comment">//读取</span>
                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4096</span>];
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){
                    <span class="hljs-keyword">int</span> read = dataInputStream.read(bytes, <span class="hljs-number">0</span>, bytes.length);
                    <span class="hljs-keyword">if</span> (read == -<span class="hljs-number">1</span>){
                        <span class="hljs-keyword">break</span>;
                    }
                }
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
    }

    <span class="hljs-comment">/**
     * 传统IO客户端
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">oldClient</span><span class="hljs-params">()</span></span>{
        Socket socket = <span class="hljs-keyword">null</span>;
        FileInputStream inputStream = <span class="hljs-keyword">null</span>;
        DataOutputStream dataOutputStream = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6666</span>);
            <span class="hljs-comment">//需要发送的文件</span>
            String fileName = <span class="hljs-string">"C:\\duwk\\code\\myself\\frame-master\\netty\\src\\main\\resources\\file\\jdk1.8.0_51.zip"</span>;
            inputStream = <span class="hljs-keyword">new</span> FileInputStream(fileName);
            <span class="hljs-comment">//socket输出流</span>
            dataOutputStream = <span class="hljs-keyword">new</span> DataOutputStream(socket.getOutputStream());
            <span class="hljs-comment">//文件存入byte数组并写入socket的输出流</span>
            <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4096</span>];
            <span class="hljs-keyword">long</span> readCount;
            <span class="hljs-keyword">long</span> total = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
            <span class="hljs-keyword">while</span> ((readCount = inputStream.read(bytes)) &gt;= <span class="hljs-number">0</span>){
                total += readCount;
                dataOutputStream.write(bytes);
            }
            <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
            System.out.println(<span class="hljs-string">"传统IO方式=========总共传输字节："</span> + total +<span class="hljs-string">"耗时："</span> + (end - start));
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
                socket.close();
                inputStream.close();
                dataOutputStream.close();
            } <span class="hljs-keyword">catch</span> (IOException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }
        }
    }

    <span class="hljs-comment">/**
     * 零拷贝服务端
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newServer</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">try</span> {
            InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9999</span>);
            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
            ServerSocket socket = serverSocketChannel.socket();
            socket.bind(inetSocketAddress);
            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">4096</span>);
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>){
                <span class="hljs-comment">//等待客户端连接</span>
                SocketChannel socketChannel = serverSocketChannel.accept();
                <span class="hljs-comment">//读取客户端数据</span>
                <span class="hljs-keyword">int</span> read = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (read != -<span class="hljs-number">1</span>){
                    read = socketChannel.read(byteBuffer);
                    <span class="hljs-comment">// position = 0;    mark = -1;  重置bytebuffer</span>
                    byteBuffer.rewind();
                }
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
    }

    <span class="hljs-comment">/**
     * 零拷贝客户端
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">newClkient</span><span class="hljs-params">()</span></span>{
        SocketChannel socketChannel = <span class="hljs-keyword">null</span>;
        FileInputStream inputStream = <span class="hljs-keyword">null</span>;
        FileChannel fileChannel = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            InetSocketAddress inetSocketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">9999</span>);
            socketChannel = SocketChannel.open();
            socketChannel.connect(inetSocketAddress);
            String fileName = <span class="hljs-string">"C:\\duwk\\code\\myself\\frame-master\\netty\\src\\main\\resources\\file\\jdk1.8.0_51.zip"</span>;
            inputStream = <span class="hljs-keyword">new</span> FileInputStream(fileName);
            fileChannel = inputStream.getChannel();

            <span class="hljs-comment">/*在linux下一个transferTo函数就可以完成传输   在windows下transferTo每次只能发送8M，需要分段发送，分段时要注意发送的起始位置
                参数说明
                position : 读取或写入的起始位置
                count : 传输大小
                target : 目标channel
            */</span>
            <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">long</span> number = fileChannel.size() / (<span class="hljs-number">8</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>);
            number = number + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;number;i++){
                <span class="hljs-keyword">long</span> position = i * (<span class="hljs-number">8</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>);
                count += fileChannel.transferTo(position, fileChannel.size(), socketChannel);
            }
            <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
            System.out.println(<span class="hljs-string">"零拷贝方式=========发送的总共字节数："</span> + count + <span class="hljs-string">"耗时："</span> + (end -start));
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
                socketChannel.close();
                inputStream.close();
                fileChannel.close();
            } <span class="hljs-keyword">catch</span> (IOException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }
        }
    }

}
</div></code></pre>
<p>运行结果：</p>
<p><img src="image/netty/零拷贝运行结果.png" alt=""></p>
<h2 id="12netty%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">12、Netty基本介绍</h2>
<p>1、原生NIO存在的问题</p>
<pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、NIO类库和API繁杂，使用麻烦

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、要熟悉多线程编程，NIO涉及到Reactor模型

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3、开发工作量及难度大，客户端重连、网络闪断、半包读写、失败缓存、网络拥堵、异常流处理等

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4、NIO中epoll的bug  会导致Selector空轮询，最终导致CPU占用100%，JDK1.7中问题依然存在
</code></pre>
<p>2、netty是什么</p>
<pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、netty是由jboss提供的一个Java开源框架；netty提供异步的、基于事件驱动的网络应用程序框架，用以快速开发高性能、高可靠性的网络IO程序

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、简化和流程化了NIO的开发过程
</code></pre>
<p>3、netty架构图</p>
<p><img src="image/netty/netty架构图.png" alt=""></p>
<p>解析：</p>
<pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、Core：零拷贝 + API库 + 扩展的事件模型

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、Protocol Support：支持的协议

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3、Transport Service：支持的传输服务
</code></pre>
<p>4、优点</p>
<p><img src="image/netty/netty优点.png" alt="netty优点"></p>
<h2 id="13%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8Dreactor">13、线程模型介绍(Reactor)</h2>
<p>1、目前存在的线程模型：<strong>传统阻塞IO模型、Reactor模型</strong></p>
<p>2、根据Reactor的数量和处理资源线程池数量不同有3种典型的实现</p>
<pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、单Reactor单线程

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、单Reactor多线程

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3、主从Reactor多线程
</code></pre>
<p><strong>3、Netty线程模式：基于主从Reactor多线程模式进行了一定改进，其中主从Reactor多线程模型有多个Reactor</strong></p>
<p>4、传统阻塞IO模型</p>
<p><img src="image/netty/传统阻塞IO模型.png" alt=""></p>
<p>5、Reactor模型</p>
<pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1、基于IO复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接，当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2、基于线程池复用资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务；
</code></pre>
<p><img src="image/netty/Reactor模型.png" alt="Reactor模型.png"></p>
<pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3、核心组成

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a、Reactor：在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。就像电话接线员，接听来自客户的电话并将线路转移到适当的联系人；

&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b、Handlers：处理程序执行IO事件要完成的实际事件。Reactor通过调度适当的处理程序来相应IO事件，处理程序执行非阻塞操作；
</code></pre>
<p>6、三种Reactor实现模型解析</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>图解</th>
<th>说明</th>
<th>优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>单Reactor单线程</td>
<td><img src="image/netty/单Reactor单线程模型.png" alt=""></td>
<td><img src="image/netty/单Reactor单线程模型说明.png" alt=""></td>
<td><img src="image/netty/单Reactor单线程模型优缺点.png" alt=""></td>
</tr>
<tr>
<td>单Reactor多线程</td>
<td><img src="image/netty/单Reactor多线程模型.png" alt=""></td>
<td><img src="image/netty/单Reactor多线程模型说明.png" alt=""></td>
<td><img src="image/netty/单Reactor多线程优缺点.png" alt=""></td>
</tr>
<tr>
<td>主从Reactor多线程</td>
<td><img src="image/netty/主从Reactor多线程模型.png" alt=""></td>
<td><img src="image/netty/主从Reactor多线程模型说明.png" alt=""></td>
<td><img src="image/netty/主从Reactor多线程模型优缺点.png" alt=""></td>
</tr>
</tbody>
</table>
<h2 id="14netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">14、Netty线程模型</h2>
<p>1、图解：</p>
<p><img src="image/netty/Netty线程模型.png" alt=""></p>
<p>2、说明：</p>
<p>    1、Netty抽象出两组线程池BossGroup专门负责接受客户端连接，WorkerGroup专门负责网络的读写；</p>
<p>    2、BossGroup和WorkerGroup类型都是NioEventLoopGroup；</p>
<p>    3、NioEventLoopGroup相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是NioEventLoop；</p>
<p>    4、NioEventLoop表示一个不断循环的执行处理任务的线程，每个NioEventLoop都有一个selector，用于监听绑定在其上的socket的网络通讯；</p>
<p>    5、NioEventLoopGroup可以有多个线程，即可以含有多个NioEventLoop</p>
<p>    6、每个Boss下的NioEventLoop分三步执行</p>
<p>        a、轮询accept事件</p>
<p>        b、处理accept事件，与client建立连接生成NioSocketChannel，并将其注册到某个worker NIOEventLoop上的selector</p>
<p>        c、处理任务队列的任务，即runAllTasks</p>
<p>    7、每个Worker下的NioEventLoop循环执行的步骤</p>
<p>        a、轮询read、write事件</p>
<p>        b、处理io事件，即read、write事件，在对应的NioSocketChannel处理</p>
<p>        c、处理任务队列的任务，即runAllTasks</p>
<p>    8、Pipeline：每个Worker NioEventLoop处理业务时会使用pipeline(管道)，pipeline中包含了channel，即通过pipeline可以获取到对应channel，管道中维护了很多的处理器；<em><strong>Netty中的管道为双向链表结构</strong></em>！</p>
<p>3、补充：</p>
<p>    1、netty抽象出两组线程池，BossGroup专门负责接受客户端连接，WorkerGroup专门负责网络读写操作；</p>
<p>    2、NioEventLoop表示一个不断循环执行处理任务的线程，每个NioEventLoop都有一个selector用于监听绑定在其上的socket网络通道；</p>
<p>    3、NioEventLoop内部采用串行化设计，从消息的读取-&gt;解码-&gt;编码-&gt;发送，始终由IO线程NioEventLoop负责；</p>
<p>        NioEventLoopGroup下包含多个NioEventLoop</p>
<p>        每个NioEventLoop中包含一个Selector，一个taskQueue</p>
<p>        每个NioEventLoop的Selector上可以注册监听多个NioChannel</p>
<p>        每个NioEvent只会绑定在唯一的NioEventLoop上</p>
<p>        每个NioChannel都绑定有一个自己的ChannelPipeline</p>
<h2 id="15netty%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B">15、Netty入门案例</h2>
<p>构建服务端和客户端消息通信：</p>
<p>服务端：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.dwk.netty.demo1;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.*;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerDemo</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">new</span> NettyServerDemo().nettyServer();
    }

    <span class="hljs-comment">/**
     * 服务端
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nettyServer</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">/*
        1、创建两个线程组 bossGroup和workerGroup
        2、bossGroup只是处理连接请求  真正和客户端业务处理会交给workerGroup完成
        3、bossGroup 和 workerGroup都是无限循环
         */</span>
        NioEventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        NioEventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();

        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//创建服务端启动配置</span>
            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();
            serverBootstrap.group(bossGroup, workerGroup) <span class="hljs-comment">//设置线程组</span>
                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>) //使用<span class="hljs-title">NioSocketChannel</span> 作为服务端通道实现
                    .<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BACKLOG</span>, 128) //设置线程队列得到的连接个数 (设置全连接队列的大小)
                    .<span class="hljs-title">childOption</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_KEEPALIVE</span>, <span class="hljs-title">true</span>) //设置保持活动连接状态
                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>{ <span class="hljs-comment">// 创建一个通道测试对象</span>
                        <span class="hljs-comment">//给pipeline设置处理器</span>
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                            <span class="hljs-comment">//具体处理客户端消息的处理器 channelHandlers</span>
                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());
                        }
                    }); <span class="hljs-comment">//给workerGroup 的EventLoop 对应的管道设置处理器</span>

            System.out.println(<span class="hljs-string">"服务端初始化完成"</span>);

            <span class="hljs-comment">//绑定端口 并设置同步</span>
            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">6666</span>).sync();

            <span class="hljs-comment">//对关闭通道进行监听,涉及到异步模型</span>
            channelFuture.channel().closeFuture().sync();
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }<span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">//关闭线程组  优雅关闭</span>
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }

    }

    <span class="hljs-comment">/**
     * 适配器模式
     * 自定义服务端处理器   需要继承netty规定好的适配器
     */</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{

        <span class="hljs-comment">/*
        1、读取数据事件   可以读取客户端发送的消息
        2、ChannelHandlerContext tx ： 上下文对象，含有pipeline管道、通道、地址
        3、Object msg ： 客户端发送的消息
         */</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{
            <span class="hljs-comment">//将msg转换成byteBuffer</span>
            ByteBuf buf = (ByteBuf) msg;
            System.out.println(<span class="hljs-string">"服务端接收到客户端"</span> + ctx.channel().remoteAddress()+ <span class="hljs-string">"发来的消息："</span> + buf.toString(CharsetUtil.UTF_8));
            <span class="hljs-comment">//super.channelRead(ctx, msg);</span>
        }

        <span class="hljs-comment">/*
        数据读取完毕，返回数据给客户端
         */</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{
            <span class="hljs-comment">// 将数据写入到缓冲并刷新,发送的数据需要编码</span>
            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"服务端返回数据"</span>,CharsetUtil.UTF_8));
            <span class="hljs-comment">//super.channelReadComplete(ctx);</span>
        }

        <span class="hljs-comment">/*
        处理异常(异常处理器)
         */</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{
            System.out.println(<span class="hljs-string">"和"</span> + ctx.channel().remoteAddress() + <span class="hljs-string">"通信发生异常"</span>);
            ctx.close();
            <span class="hljs-comment">//super.exceptionCaught(ctx, cause);</span>
        }
    }

}

</div></code></pre>
<p>客户端:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.dwk.netty.demo1;

<span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;
<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelFuture;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;
<span class="hljs-keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientDemo</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">new</span> NettyClientDemo().nettyClient();
    }

    <span class="hljs-comment">/**
     * 客户端
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nettyClient</span><span class="hljs-params">()</span></span>{
        <span class="hljs-comment">// 客户端需要一个事件循环组</span>
        NioEventLoopGroup eventExecutors = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//创建启动配置</span>
            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();
            bootstrap.group(eventExecutors) <span class="hljs-comment">//设置线程组</span>
                    .channel(NioSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>) //设置客户端通道的实现类
                    .<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt;() </span>{
                        <span class="hljs-comment">//设置客户端处理器</span>
                        <span class="hljs-meta">@Override</span>
                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());
                        }
                    });
            System.out.println(<span class="hljs-string">"客户端初始化完成"</span>);
            <span class="hljs-comment">//启动客户端连接服务端 并设置同步</span>
            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">6666</span>).sync();
            <span class="hljs-comment">//给关闭通道进行监听</span>
            channelFuture.channel().closeFuture().sync();
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }<span class="hljs-keyword">finally</span> {
            eventExecutors.shutdownGracefully();
        }
    }

    <span class="hljs-comment">/**
     * 自定义客户端处理器
     */</span>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>{

        <span class="hljs-comment">//当通道就绪就会触发该方法</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>{
            <span class="hljs-comment">//给服务器发送消息</span>
            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">"我是客户端"</span>, CharsetUtil.UTF_8));
            <span class="hljs-keyword">super</span>.channelActive(ctx);
        }

        <span class="hljs-comment">//当通道有读取事件时会触发该方法</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{
            ByteBuf buf = (ByteBuf) msg;
            System.out.println(<span class="hljs-string">"客户端接受到服务端的消息:"</span> + buf.toString(CharsetUtil.UTF_8));
            <span class="hljs-comment">//super.channelRead(ctx, msg);</span>
        }

        <span class="hljs-comment">//异常处理器</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>{
            cause.printStackTrace();
            <span class="hljs-keyword">super</span>.exceptionCaught(ctx, cause);
        }
    }

}


</div></code></pre>
<p>运行结果:</p>
<table>
<thead>
<tr>
<th>服务端</th>
<th>客户端</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="image/netty/Netty服务端运行结果.png" alt="Netty服务端运行结果"></td>
<td><img src="image/netty/Netty客户端运行结果.png" alt="Netty客户端运行结果"></td>
</tr>
</tbody>
</table>
<h2 id="16taskqueue%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97">16、taskQueue任务队列</h2>
<p>1、任务队列中的Task有三种典型使用场景</p>
<p>    1、用户程序自定义的普通任务</p>
<p>    2、用户自定义定时任务</p>
<p>    3、非当前Reactor线程调用Channel的各种方法；</p>
<p>2、将耗时的业务逻辑放至任务队列进行异步处理，减少服务端和客户端间通信的耗时；</p>
<h2 id="17%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B">17、异步模型</h2>
<p>1、异步的概念和同步相反；当一个异步过程调用发出后，调用者不能立刻得到结果，实际处理这个调用的组件在完成后通过状态、通知和回调来通知调用者；</p>
<p>2、netty中的IO操作是异步的，包括Bind、Write、Connect等操作会简单的返回一个ChannelFuture；</p>
<p>3、调用者并不能立刻获得结果，而是通过Future-Listener机(任务监听)机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果；</p>
<p>4、netty的异步模型是建立在future和callback之上的；callback就是回调，重点说Future，它的核心思想是：假设一个方法run，计算过程可能非常耗时，等待fun返回显然不合适。那么可以在调用fun的时候立马返回一个Future，后续可以通过Future去监控方法的处理过程 即 Future-Listener机制；</p>
<p>5、Future：表示异步的执行结果可以通过它提供的方法来检测执行是否完成，比如检索计算等；</p>
<p>6、ChannelFuture是一个接口，可以添加监听器，当监听的事件发生时就会通知到监听器；</p>
<p>7、工作原理：</p>
<p><img src="image/netty/异步模型工作原理.png" alt=""></p>
<p>在使用Netty进行编程时，拦截操作和转换出入站数据只需要提供callback或利用future即可，这使得链式操作简单、高效并有利于编写可重用的通用的代码；</p>
<p>Netty框架的目标就是让业务逻辑从网络基础应用编码中分离出来；</p>
<p>8、当Future对象刚刚创建时处于非完成状态，调用者可以通过返回的ChannelFuture来获取操作执行的状态，注册监听函数来执行完成后的操作；常见有如下操作：</p>
<p>    1、通过isDone方法来判断当前操作是否完成；</p>
<p>    2、通过isSuccess方法来判断已完成的当前操作是否成功；</p>
<p>    3、通过getCause方法来获取已完成的当前操作失败的原因；</p>
<p>    4、通过isCancelled方法来判断已完成的当前操作是否被取消；</p>
<p>    5、通过addListener方法来注册监听器，当操作已完成(isDone方法返回完成)，将会通知指定的监听器；如果Future对象已完成，则通知指定的监听器；</p>
<p>9、代码示例 (给bind()绑定端口方法添加监视器)：</p>
<pre class="hljs"><code><div> 	    <span class="hljs-comment">//绑定端口 并设置同步</span>
            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">6666</span>).sync();

            <span class="hljs-comment">//给bind方法添加监听器</span>
            channelFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                    <span class="hljs-keyword">if</span> (channelFuture.isSuccess()){
                        System.out.println(<span class="hljs-string">"监听端口成功"</span>);
                    }<span class="hljs-keyword">else</span>{
                        System.out.println(<span class="hljs-string">"监听端口失败"</span>);
                    }
                }
            });

</div></code></pre>
<p><em>优点：相比传统阻塞IO ，执行IO操作后线程会被阻塞住，直到操作完成；异步处理的好处是不会造成线程阻塞，线程在IO操作期间可以执行别的程序，在高并发情形下会更稳定和更高的吞吐量；</em></p>
<h2 id="18%E4%BD%BF%E7%94%A8netty%E5%BC%80%E5%8F%91http%E6%9C%8D%E5%8A%A1%E6%A1%88%E4%BE%8B">18、使用Netty开发HTTP服务案例</h2>
<p>demo代码：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> com.dwk.netty.demo2.service;

<span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;
<span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;
<span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;
<span class="hljs-keyword">import</span> io.netty.channel.*;
<span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;
<span class="hljs-keyword">import</span> io.netty.handler.codec.http.*;
<span class="hljs-keyword">import</span> io.netty.util.CharsetUtil;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyHttpServiceImp</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">new</span> NettyHttpServiceImp().server();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span>{
        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();
        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();

        <span class="hljs-keyword">try</span>{
            <span class="hljs-comment">//服务端启动配置</span>
            ServerBootstrap serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();
            serverBootstrap.group(bossGroup,workerGroup)
                    .channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)
                    .<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ServerInitializer</span>())</span>;
            <span class="hljs-comment">//绑定端口启动服务</span>
            ChannelFuture channelFuture = serverBootstrap.bind(<span class="hljs-number">6666</span>).sync();

            <span class="hljs-comment">//添加bind监听器</span>
            channelFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>{
                    <span class="hljs-keyword">if</span> (channelFuture.isSuccess()){
                        System.out.println(<span class="hljs-string">"服务端启动成功"</span>);
                    }<span class="hljs-keyword">else</span>{
                        System.out.println(<span class="hljs-string">"服务端启动失败"</span>);
                    }
                }
            });

            <span class="hljs-comment">//监听关闭端口</span>
            channelFuture.channel().closeFuture().sync();

        }<span class="hljs-keyword">catch</span> (Exception e){
            e.printStackTrace();
        }<span class="hljs-keyword">finally</span> {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }

    }

}

<span class="hljs-comment">/**
 * 服务端初始化器  处理pipeline
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-comment">//获取管道</span>
        ChannelPipeline pipeline = socketChannel.pipeline();
        <span class="hljs-comment">//添加解码器   HttpServerCodec-netty提供的Http编解码器</span>
        pipeline.addLast(<span class="hljs-string">"MyHttpServerCodec"</span>,<span class="hljs-keyword">new</span> HttpServerCodec());
        <span class="hljs-comment">//添加自定义处理器</span>
        pipeline.addLast(<span class="hljs-string">"MyServerHandler"</span>,<span class="hljs-keyword">new</span> ServerHandler());
    }
}

<span class="hljs-comment">/**
 * 服务端自定义处理器
 * SimpleChannelInboundHandler extends ChannelInboundHandlerAdapter
 * HttpObject : 客户端和服务端相互通讯的数据被封装成 HttpObject
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">HttpObject</span>&gt;</span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, HttpObject msg)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-comment">//判断消息类型</span>
        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> HttpRequest){
            System.out.println(<span class="hljs-string">"开始处理Http请求..."</span>);
            <span class="hljs-comment">// 回复信息给浏览器 回复的消息要符合Http协议</span>
            ByteBuf content = Unpooled.copiedBuffer(<span class="hljs-string">"我是服务器返回的消息"</span>, CharsetUtil.UTF_8);
            <span class="hljs-comment">//构建http响应</span>
            DefaultFullHttpResponse defaultFullHttpResponse = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);
            defaultFullHttpResponse.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="hljs-string">"application/json"</span>);
            defaultFullHttpResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());
            <span class="hljs-comment">//将构建好的response返回</span>
            channelHandlerContext.writeAndFlush(defaultFullHttpResponse);
        }
    }
}

</div></code></pre>
<p>运行结果：</p>
<p><img src="image/netty/demo-http运行结果.png" alt=""></p>
<h2 id="19netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97">19、Netty核心模块</h2>
<p>1、Bootstrap和ServerBootstrap</p>
<p>    1、Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类；相当于是启动配置；</p>
<p>    2、常见方法：</p>
<p><img src="image/netty/strap常用方法.png" alt=""></p>
<p>2、Future和ChannelFuture</p>
<p>    1、Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理。但是也可以过一会等它执行完成或者直接注册一个监听器，具体实现就是通过Future和ChannelFuture 他们可以注册一个监听，当操作执行成功或者失败时监听会自动触发注册的监听事件。</p>
<p>    2、常见方法：
Channel channel() : 返回当前正在进行IO操作的通道；</p>
<p>ChannelFuture sync() : 等待异步操作执行完毕；</p>
<p>3、Channel</p>
<p>    1、Netty网络通信的组件，能够用于执行网络IO操作；</p>
<p>    2、通过Channel可获得当前网络连接的通道状态</p>
<p>    3、通过Channel可获得网络连接的配置参数(例如接受缓冲区大小)</p>
<p>    4、Channel提供异步的网络IO操作(如建立连接、读写、绑定端口)，异步调用意味着任何IO调用都将立即返回但是不保证在调用结束时所请求的IO操作已完成</p>
<p>    5、调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上可以将IO操作成功、失败或者取消时的回调通知到客户端；</p>
<p>    6、支持关联IO操作与对应的处理程序；</p>
<p>    7、不同协议、不同的阻塞类型的连接都有不同的Channel类型与之对应，常用的Channel类型：</p>
<p><img src="image/netty/常用的Channel类型.png" alt=""></p>
<p>4、Selector</p>
<p>    1、Netty基于Selector对象实现<em><strong>IO多路复用</strong></em>，通过Selector一个线程可以监听多个连接的Channel事件；</p>
<p>    2、当向一个Selector中注册Channel后，Selector内部的机制就可以自动不断的查询（循环）这些注册的Channel中是否有已就绪的IO事件（可读、可写、网络连接完成等），这样程序就可以很简单地使用一个线程高效管理多个Channel；</p>
<p>5、ChannelHandler</p>
<p><img src="image/netty/ChannelHandler类图.png" alt=""></p>
<p>处理IO事件或者拦截IO操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序；</p>

</body>
</html>
